#cpp 2022/7/10
## return语句
- return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。
- 两种形式
	- return; //没有返回值void
	- return expression;
- 具有返回值的函数
	1. 主函数main的返回值
	2. 返回非引用类型
	3. 返回引用
	4. 千万不要返回局部对象的引用
	5. 引用返回左值,可以进行赋值
	6. 千万不要返回指向局部对象的指针
```cpp
#include <iostream>
#include <iostream>
using namespace std;
int& add_one(int &x)
{
	++x;
	return x;
 }
//const 表示不能修改 
const string& shorter_string(const string &s1, const string &s2)
{
	return s1.size() >= s2.size() ? s1 : s2;
}
//const string& mainp(const string &s)
//{
//	string ret = s;
//	return ret;//！！！：返回的是ret，但是ret是一个局部对象！函数调用结束即被清除 
//}
char& get_val(string &s, string::size_type ix)
{
	return s[ix];
 } 

int main()
{
	int a=1;
	int &b = add_one(a);
	++b;
	cout << "a: " << a << " b: " << b << endl;
	cout << "The shorter string is: " << shorter_string("hello", "dog") << endl;
	
	string s("hello");
	char &c = get_val(s, 1);
	c = 'k';
	cout << s << endl; 
	return 0;//返回0表示正常 
}
```
## 返回类类型的函数和调用运算符
- 调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。
```cpp
//调用string对象的size成员，该string对象是由shorterString函数返回的
auto sz = shorterString(s1, s2).size()
```
## 引用返回左值
- 调用一个返回引用的函数得到左值，其他返回类型得到右值。
- 能为返回类型是非常量引用的函数的结果赋值
```cpp
char &get_val(string &str, string::size_type ix)
{
	return str[ix];
}
int main()
{
	string s("a value");
	cout << a << endl; //输出a value
	get_val(s, 0) = 'A'; //将s[0]的值改为A
	cout << s << endl; //输出A value
	return 0;
}
```
## 列表初始化返回值
- C++11新标准规定，函数可以返回花括号包围的值的列表，用来表示函数返回的临时变量进行初始化
	- 如果列表为空，临时量执行值初始化
	- 否则，返回的值由函数的返回类型决定
- 如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间，
- 如果函数返回的是类类型，由类本身定义初始值如何使用
```cpp
vector<string> process()
{
	//...
	//expected 和 actual 是 string对象
	if(expected.empty())
		return {};
	else if (expected == actual)
		return {"functionX", "okay"};
	else
		return {"functionX", expected, actual};
}
```
## 主函数main的返回值
- `main`函数的返回值可以看作是**状态指示器**。返回0表示执行成功，返回其他值表示执行失败。其中非0值得具体含义依机器而定。
- 为了使返回的值与机器无关，cstdlib头文件定义了两个**预处理变量**，可以是使用这两个变量分别表示成功与失败。
- 因为是预处理变量，所以既不能在前面加上`std::`，也不能在`using`声明中出现。
```cpp
int main()
{
	if(some_failure)
		return EXIT_FAILURE;
	else
		return EXIT_SUCCESS;
}
```
## 什么是递归？
- 递归是神，迭代是人
- 自己调用自己
- 老和尚讲故事
- 计算阶乘：
	- 使用递归
	- 使用阶乘(就是循环)
```cpp
#include <iostream>
using namespace std;
void doA()
{
	cout << "hello" << endl;
	doA();
}
int Fact(int x)//求阶乘 
{
	if(x == 0 )
		return 1;
	return x * Fact(x-1);
}
int Fibo(int x)
{
	if(x == 1 || x == 2)
		return x;
	return x + Fibo(x-1);
}

int main()
{
//	doA();
	for(int a=1; a<=10; ++a)
		cout << a << "!=" << Fibo(a) << endl;
	return 0;
}
```